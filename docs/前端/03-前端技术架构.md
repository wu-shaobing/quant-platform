# æŠ€æœ¯æ¶æ„è®¾è®¡

## ğŸ—ï¸ æ•´ä½“æ¶æ„

### ç³»ç»Ÿæ¶æ„å›¾

```mermaid
graph TB
    subgraph "å‰ç«¯åº”ç”¨å±‚"
        A[Vue 3 åº”ç”¨] --> B[ç»„ä»¶å±‚]
        B --> C[é¡µé¢è§†å›¾]
        B --> D[é€šç”¨ç»„ä»¶]
        B --> E[ä¸šåŠ¡ç»„ä»¶]
    end
    
    subgraph "ä¸šåŠ¡é€»è¾‘å±‚"
        F[Composables] --> G[çŠ¶æ€ç®¡ç† Pinia]
        G --> H[æœåŠ¡å±‚]
        H --> I[å·¥å…·å‡½æ•°]
    end
    
    subgraph "æ•°æ®è®¿é—®å±‚"
        J[APIæ¥å£] --> K[HTTP Client]
        J --> L[WebSocket]
        K --> M[è¯·æ±‚æ‹¦æˆªå™¨]
        K --> N[å“åº”æ‹¦æˆªå™¨]
    end
    
    subgraph "åŸºç¡€è®¾æ–½å±‚"
        O[è·¯ç”±ç³»ç»Ÿ] --> P[æ’ä»¶ç³»ç»Ÿ]
        P --> Q[æ„å»ºå·¥å…· Vite]
        Q --> R[ç±»å‹ç³»ç»Ÿ TypeScript]
    end
    
    A --> F
    F --> J
    J --> S[åç«¯APIæœåŠ¡]
    L --> T[WebSocketæœåŠ¡]
```

### ğŸ”„ æ•°æ®æµæ¶æ„

```mermaid
sequenceDiagram
    participant U as ç”¨æˆ·ç•Œé¢
    participant C as ç»„ä»¶
    participant CO as Composables
    participant S as Store
    participant API as APIæœåŠ¡
    participant WS as WebSocket
    participant BE as åç«¯
    
    U->>C: ç”¨æˆ·æ“ä½œ
    C->>CO: è°ƒç”¨ä¸šåŠ¡é€»è¾‘
    CO->>S: æ›´æ–°çŠ¶æ€
    CO->>API: å‘é€HTTPè¯·æ±‚
    API->>BE: è¯·æ±‚æ•°æ®
    BE-->>API: è¿”å›æ•°æ®
    API-->>CO: å“åº”æ•°æ®
    CO->>S: æ›´æ–°çŠ¶æ€
    S-->>C: å“åº”å¼æ›´æ–°
    C-->>U: ç•Œé¢æ›´æ–°
    
    Note over WS,BE: å®æ—¶æ•°æ®æµ
    BE->>WS: æ¨é€å®æ—¶æ•°æ®
    WS->>S: æ›´æ–°å®æ—¶çŠ¶æ€
    S-->>C: è§¦å‘ç•Œé¢æ›´æ–°
    C-->>U: å®æ—¶ç•Œé¢æ›´æ–°
```

## ğŸ—„ï¸ çŠ¶æ€ç®¡ç†æ¶æ„

### Pinia Store è®¾è®¡

```typescript
// çŠ¶æ€ç®¡ç†æ¶æ„è®¾è®¡
interface StoreArchitecture {
  // æ ¸å¿ƒStore
  auth: AuthStore          // è®¤è¯çŠ¶æ€
  user: UserStore          // ç”¨æˆ·ä¿¡æ¯
  ui: UIStore             // UIçŠ¶æ€
  
  // ä¸šåŠ¡Store
  market: MarketStore      // è¡Œæƒ…æ•°æ®
  trading: TradingStore    // äº¤æ˜“æ•°æ®
  strategy: StrategyStore  // ç­–ç•¥æ•°æ®
  backtest: BacktestStore  // å›æµ‹æ•°æ®
  portfolio: PortfolioStore // æŠ•èµ„ç»„åˆ
  
  // è¾…åŠ©Store
  notification: NotificationStore // é€šçŸ¥
  settings: SettingsStore        // è®¾ç½®
}
```

### çŠ¶æ€åˆ†ç±»ä¸èŒè´£

#### 1. å…¨å±€çŠ¶æ€ (Global State)
```typescript
// src/stores/modules/ui.ts
export const useUIStore = defineStore('ui', () => {
  // ä¸»é¢˜çŠ¶æ€
  const theme = ref<'light' | 'dark' | 'auto'>('auto')
  const isDarkMode = computed(() => {
    if (theme.value === 'auto') {
      return window.matchMedia('(prefers-color-scheme: dark)').matches
    }
    return theme.value === 'dark'
  })
  
  // å¸ƒå±€çŠ¶æ€
  const sidebarCollapsed = ref(false)
  const fullscreen = ref(false)
  
  // åŠ è½½çŠ¶æ€
  const loading = ref(false)
  const loadingText = ref('')
  
  // æ“ä½œæ–¹æ³•
  const toggleTheme = () => {
    const themes = ['light', 'dark', 'auto']
    const currentIndex = themes.indexOf(theme.value)
    theme.value = themes[(currentIndex + 1) % themes.length] as any
  }
  
  const toggleSidebar = () => {
    sidebarCollapsed.value = !sidebarCollapsed.value
  }
  
  const setLoading = (state: boolean, text = '') => {
    loading.value = state
    loadingText.value = text
  }
  
  return {
    // çŠ¶æ€
    theme,
    isDarkMode,
    sidebarCollapsed,
    fullscreen,
    loading,
    loadingText,
    
    // æ“ä½œ
    toggleTheme,
    toggleSidebar,
    setLoading
  }
})
```

#### 2. ä¸šåŠ¡çŠ¶æ€ (Business State)
```typescript
// src/stores/modules/market.ts
export const useMarketStore = defineStore('market', () => {
  // è¡Œæƒ…æ•°æ®çŠ¶æ€
  const quotes = ref<Map<string, QuoteData>>(new Map())
  const klineData = ref<Map<string, KLineData[]>>(new Map())
  const watchlist = ref<string[]>([])
  
  // è®¢é˜…çŠ¶æ€
  const subscriptions = ref<Set<string>>(new Set())
  
  // WebSocketè¿æ¥çŠ¶æ€
  const wsConnected = ref(false)
  const wsReconnectCount = ref(0)
  
  // è®¡ç®—å±æ€§
  const watchlistQuotes = computed(() => {
    return watchlist.value.map(symbol => quotes.value.get(symbol)).filter(Boolean)
  })
  
  // æ“ä½œæ–¹æ³•
  const updateQuote = (symbol: string, data: QuoteData) => {
    quotes.value.set(symbol, data)
  }
  
  const updateKLineData = (symbol: string, data: KLineData[]) => {
    klineData.value.set(symbol, data)
  }
  
  const addToWatchlist = (symbol: string) => {
    if (!watchlist.value.includes(symbol)) {
      watchlist.value.push(symbol)
      subscribeSymbol(symbol)
    }
  }
  
  const removeFromWatchlist = (symbol: string) => {
    const index = watchlist.value.indexOf(symbol)
    if (index > -1) {
      watchlist.value.splice(index, 1)
      unsubscribeSymbol(symbol)
    }
  }
  
  const subscribeSymbol = (symbol: string) => {
    subscriptions.value.add(symbol)
    // WebSocketè®¢é˜…é€»è¾‘
  }
  
  const unsubscribeSymbol = (symbol: string) => {
    subscriptions.value.delete(symbol)
    // WebSocketå–æ¶ˆè®¢é˜…é€»è¾‘
  }
  
  return {
    // çŠ¶æ€
    quotes,
    klineData,
    watchlist,
    subscriptions,
    wsConnected,
    wsReconnectCount,
    
    // è®¡ç®—å±æ€§
    watchlistQuotes,
    
    // æ“ä½œ
    updateQuote,
    updateKLineData,
    addToWatchlist,
    removeFromWatchlist,
    subscribeSymbol,
    unsubscribeSymbol
  }
})
```

#### 3. æœ¬åœ°çŠ¶æ€ (Local State)
```typescript
// ç»„ä»¶å†…éƒ¨çŠ¶æ€ï¼Œä½¿ç”¨ Composables ç®¡ç†
export const useOrderForm = () => {
  const form = reactive({
    symbol: '',
    side: 'buy' as 'buy' | 'sell',
    type: 'limit' as 'limit' | 'market',
    price: 0,
    quantity: 0
  })
  
  const rules = {
    symbol: [{ required: true, message: 'è¯·é€‰æ‹©è‚¡ç¥¨' }],
    price: [{ required: true, message: 'è¯·è¾“å…¥ä»·æ ¼' }],
    quantity: [{ required: true, message: 'è¯·è¾“å…¥æ•°é‡' }]
  }
  
  const submitOrder = async () => {
    // æäº¤è®¢å•é€»è¾‘
  }
  
  const resetForm = () => {
    Object.assign(form, {
      symbol: '',
      side: 'buy',
      type: 'limit',
      price: 0,
      quantity: 0
    })
  }
  
  return {
    form,
    rules,
    submitOrder,
    resetForm
  }
}
```

## ğŸ”Œ ç»„åˆå¼å‡½æ•°æ¶æ„

### Composables åˆ†å±‚è®¾è®¡

```typescript
// ç»„åˆå¼å‡½æ•°æ¶æ„
interface ComposablesArchitecture {
  // æ ¸å¿ƒå±‚ - é€šç”¨åŠŸèƒ½
  core: {
    useLocalStorage: Function    // æœ¬åœ°å­˜å‚¨
    useEventListener: Function   // äº‹ä»¶ç›‘å¬
    useClipboard: Function      // å‰ªè´´æ¿
    useFullscreen: Function     // å…¨å±æ§åˆ¶
    useMediaQuery: Function     // åª’ä½“æŸ¥è¯¢
  }
  
  // ä¸šåŠ¡å±‚ - ä¸šåŠ¡é€»è¾‘
  business: {
    useAuth: Function           // è®¤è¯é€»è¾‘
    useMarketData: Function     // è¡Œæƒ…æ•°æ®
    useTradingLogic: Function   // äº¤æ˜“é€»è¾‘
    useStrategyEngine: Function // ç­–ç•¥å¼•æ“
    useRiskControl: Function    // é£é™©æ§åˆ¶
  }
  
  // UIå±‚ - ç•Œé¢äº¤äº’
  ui: {
    useModal: Function          // æ¨¡æ€æ¡†
    useToast: Function         // æ¶ˆæ¯æç¤º
    useLoading: Function       // åŠ è½½çŠ¶æ€
    useForm: Function          // è¡¨å•å¤„ç†
    useTable: Function         // è¡¨æ ¼å¤„ç†
  }
  
  // æ•°æ®å±‚ - æ•°æ®å¤„ç†
  data: {
    useApi: Function           // APIè°ƒç”¨
    useWebSocket: Function     // WebSocket
    useCache: Function         // ç¼“å­˜ç®¡ç†
    usePagination: Function    // åˆ†é¡µå¤„ç†
  }
}
```

### æ ¸å¿ƒ Composables å®ç°

#### 1. WebSocket ç®¡ç†
```typescript
// src/composables/data/useWebSocket.ts
import { ref, onUnmounted } from 'vue'

export const useWebSocket = (url: string) => {
  const socket = ref<WebSocket>()
  const connected = ref(false)
  const reconnectAttempts = ref(0)
  const maxReconnectAttempts = 5
  
  let reconnectTimer: NodeJS.Timeout | null = null
  let heartbeatTimer: NodeJS.Timeout | null = null
  
  // è¿æ¥WebSocket
  const connect = () => {
    if (socket.value?.readyState === WebSocket.OPEN) return
    
    socket.value = new WebSocket(url)
    
    socket.value.onopen = () => {
      connected.value = true
      reconnectAttempts.value = 0
      console.log('WebSocket connected to FastAPI backend')
      
      // å‘é€è®¤è¯æ¶ˆæ¯
      if (socket.value?.readyState === WebSocket.OPEN) {
        const authToken = localStorage.getItem('auth_token')
        socket.value.send(JSON.stringify({
          type: 'auth',
          data: { token: authToken }
        }))
      }
      
      // å¯åŠ¨å¿ƒè·³
      heartbeatTimer = setInterval(() => {
        if (socket.value?.readyState === WebSocket.OPEN) {
          socket.value.send(JSON.stringify({
            type: 'ping',
            timestamp: new Date().toISOString()
          }))
        }
      }, 30000)
    }
    
    socket.value.onclose = () => {
      connected.value = false
      clearTimers()
      console.log('WebSocket disconnected from FastAPI backend')
      attemptReconnect()
    }
    
    socket.value.onerror = (error) => {
      console.error('WebSocket error:', error)
    }
    
    socket.value.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data)
        handleMessage(message)
      } catch (error) {
        console.error('Failed to parse WebSocket message:', error)
      }
    }
  }
  
  // å¤„ç†æ¶ˆæ¯
  const handleMessage = (message: any) => {
    switch (message.type) {
      case 'pong':
        // å¿ƒè·³å“åº”
        break
      case 'auth_response':
        console.log('Authentication status:', message.data.status)
        break
      case 'market_data':
        // å¤„ç†è¡Œæƒ…æ•°æ®
        break
      case 'order_update':
        // å¤„ç†è®¢å•æ›´æ–°
        break
      default:
        console.log('Unknown message type:', message.type)
    }
  }
  
  // é‡è¿æœºåˆ¶
  const attemptReconnect = () => {
    if (reconnectAttempts.value >= maxReconnectAttempts) {
      console.error('Max reconnect attempts reached')
      return
    }
    
    reconnectAttempts.value++
    
    reconnectTimer = setTimeout(() => {
      if (!connected.value) {
        connect()
      }
    }, Math.pow(2, reconnectAttempts.value) * 1000) // æŒ‡æ•°é€€é¿
  }
  
  // æ¸…ç†å®šæ—¶å™¨
  const clearTimers = () => {
    if (reconnectTimer) {
      clearTimeout(reconnectTimer)
      reconnectTimer = null
    }
    if (heartbeatTimer) {
      clearInterval(heartbeatTimer)
      heartbeatTimer = null
    }
  }
  
  // å‘é€æ¶ˆæ¯
  const send = (message: any) => {
    if (connected.value && socket.value?.readyState === WebSocket.OPEN) {
      socket.value.send(JSON.stringify(message))
    }
  }
  
  // è®¢é˜…è¡Œæƒ…
  const subscribeMarketData = (symbols: string[]) => {
    send({
      type: 'subscribe',
      channel: 'market_data',
      symbols,
      fields: ['last_price', 'volume', 'bid', 'ask']
    })
  }
  
  // è®¢é˜…è®¢å•æ›´æ–°
  const subscribeOrders = () => {
    send({
      type: 'subscribe',
      channel: 'orders'
    })
  }
  
  // å–æ¶ˆè®¢é˜…
  const unsubscribe = (channel: string, symbols?: string[]) => {
    send({
      type: 'unsubscribe',
      channel,
      symbols
    })
  }
  
  // æ–­å¼€è¿æ¥
  const disconnect = () => {
    clearTimers()
    
    if (socket.value) {
      socket.value.close()
      socket.value = undefined
    }
    
    connected.value = false
    reconnectAttempts.value = 0
  }
  
  // ç»„ä»¶å¸è½½æ—¶æ¸…ç†
  onUnmounted(() => {
    disconnect()
  })
  
  return {
    socket,
    connected,
    reconnectAttempts,
    connect,
    disconnect,
    send,
    subscribeMarketData,
    subscribeOrders,
    unsubscribe
  }
}
```

#### 2. å›¾è¡¨ç®¡ç†
```typescript
// src/composables/chart/useChart.ts
import { ref, onUnmounted, nextTick } from 'vue'
import * as echarts from 'echarts'
import { debounce } from 'lodash-es'

export const useChart = (containerRef: Ref<HTMLElement | undefined>) => {
  const chart = ref<echarts.ECharts>()
  const loading = ref(false)
  
  // é˜²æŠ–çš„resizeå¤„ç†
  const debouncedResize = debounce(() => {
    chart.value?.resize()
  }, 200)
  
  // åˆå§‹åŒ–å›¾è¡¨
  const initChart = async (theme?: string) => {
    if (!containerRef.value) return
    
    await nextTick()
    
    chart.value = echarts.init(containerRef.value, theme, {
      renderer: 'canvas',
      useDirtyRect: true
    })
    
    // ç›‘å¬çª—å£resize
    window.addEventListener('resize', debouncedResize)
  }
  
  // æ›´æ–°å›¾è¡¨é…ç½®
  const updateChart = (option: any, notMerge = false) => {
    if (!chart.value) return
    
    loading.value = true
    
    try {
      chart.value.setOption(option, notMerge)
    } catch (error) {
      console.error('Chart update error:', error)
    } finally {
      loading.value = false
    }
  }
  
  // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
  const showLoading = (text = 'åŠ è½½ä¸­...') => {
    chart.value?.showLoading('default', {
      text,
      color: '#409EFF',
      textColor: '#000',
      maskColor: 'rgba(255, 255, 255, 0.8)',
      zlevel: 0
    })
  }
  
  // éšè—åŠ è½½çŠ¶æ€
  const hideLoading = () => {
    chart.value?.hideLoading()
  }
  
  // é”€æ¯å›¾è¡¨
  const disposeChart = () => {
    if (chart.value) {
      chart.value.dispose()
      chart.value = undefined
    }
    window.removeEventListener('resize', debouncedResize)
  }
  
  onUnmounted(() => {
    disposeChart()
  })
  
  return {
    chart,
    loading,
    initChart,
    updateChart,
    showLoading,
    hideLoading,
    disposeChart
  }
}
```

## ğŸŒ ç½‘ç»œæ¶æ„

### HTTP å®¢æˆ·ç«¯é…ç½®

```typescript
// src/api/http.ts
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios'
import { ElMessage } from 'element-plus'
import { useAuthStore } from '@/stores/modules/auth'

// åˆ›å»ºaxioså®ä¾‹
const createHttpClient = (): AxiosInstance => {
  const instance = axios.create({
    baseURL: import.meta.env.VITE_API_BASE_URL || '/api/v1',
    timeout: 10000,
    headers: {
      'Content-Type': 'application/json'
    }
  })
  
  // è¯·æ±‚æ‹¦æˆªå™¨
  instance.interceptors.request.use(
    (config) => {
      const authStore = useAuthStore()
      
      // æ·»åŠ è®¤è¯token
      if (authStore.token) {
        config.headers.Authorization = `Bearer ${authStore.token}`
      }
      
      // æ·»åŠ è¯·æ±‚IDç”¨äºè¿½è¸ª
      config.headers['X-Request-ID'] = generateRequestId()
      
      // æ·»åŠ æ—¶é—´æˆ³é˜²æ­¢ç¼“å­˜
      if (config.method === 'get') {
        config.params = {
          ...config.params,
          _t: Date.now()
        }
      }
      
      return config
    },
    (error) => {
      console.error('Request error:', error)
      return Promise.reject(error)
    }
  )
  
  // å“åº”æ‹¦æˆªå™¨
  instance.interceptors.response.use(
    (response: AxiosResponse) => {
      const { data, config } = response
      
      // ç»Ÿä¸€å¤„ç†å“åº”æ ¼å¼
      if (data.code !== undefined) {
        if (data.code === 200) {
          return data.data
        } else {
          ElMessage.error(data.message || 'è¯·æ±‚å¤±è´¥')
          return Promise.reject(new Error(data.message))
        }
      }
      
      return data
    },
    async (error) => {
      const { response, config } = error
      
      if (response) {
        switch (response.status) {
          case 401:
            // Tokenè¿‡æœŸï¼Œå°è¯•åˆ·æ–°
            const authStore = useAuthStore()
            try {
              await authStore.refreshToken()
              // é‡æ–°å‘é€åŸè¯·æ±‚
              return instance(config)
            } catch {
              authStore.logout()
              window.location.href = '/login'
            }
            break
            
          case 403:
            ElMessage.error('æ²¡æœ‰æƒé™è®¿é—®è¯¥èµ„æº')
            break
            
          case 404:
            ElMessage.error('è¯·æ±‚çš„èµ„æºä¸å­˜åœ¨')
            break
            
          case 500:
            ElMessage.error('æœåŠ¡å™¨å†…éƒ¨é”™è¯¯')
            break
            
          default:
            ElMessage.error(`è¯·æ±‚å¤±è´¥: ${response.status}`)
        }
      } else {
        ElMessage.error('ç½‘ç»œè¿æ¥å¤±è´¥')
      }
      
      return Promise.reject(error)
    }
  )
  
  return instance
}

// ç”Ÿæˆè¯·æ±‚ID
const generateRequestId = (): string => {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
}

export const http = createHttpClient()
```

### API æ¨¡å—è®¾è®¡

```typescript
// src/api/modules/market.ts
import { http } from '../http'
import type { 
  QuoteData, 
  KLineData, 
  MarketSearchResult,
  MarketOverviewData 
} from '@/types/api/market'

export const marketApi = {
  // è·å–å®æ—¶è¡Œæƒ…
  getQuote: (symbol: string): Promise<QuoteData> => {
    return http.get(`/market/data/${symbol}`)
  },
  
  // è·å–Kçº¿æ•°æ®
  getKLineData: (params: {
    symbol: string
    period: string
    limit?: number
    startTime?: number
    endTime?: number
  }): Promise<KLineData[]> => {
    return http.get(`/market/klines/${params.symbol}`, { 
      params: { 
        period: params.period, 
        limit: params.limit,
        start_time: params.startTime,
        end_time: params.endTime
      } 
    })
  },
  
  // æœç´¢è‚¡ç¥¨
  searchStocks: (keyword: string): Promise<MarketSearchResult[]> => {
    return http.get('/market/symbols', { 
      params: { keyword } 
    })
  },
  
  // è·å–å¸‚åœºæ¦‚è§ˆ
  getMarketOverview: (): Promise<MarketOverviewData> => {
    return http.get('/market/overview')
  },
  
  // è·å–æ¿å—æ•°æ®
  getSectorData: (): Promise<any[]> => {
    return http.get('/market/sectors')
  }
}
```

## ğŸ¨ UIæ¶æ„è®¾è®¡

### å“åº”å¼è®¾è®¡ç­–ç•¥

```typescript
// src/composables/core/useMediaQuery.ts
export const useBreakpoints = () => {
  const breakpoints = {
    xs: 480,
    sm: 768,
    md: 1024,
    lg: 1280,
    xl: 1536
  }
  
  const width = ref(window.innerWidth)
  
  const updateWidth = () => {
    width.value = window.innerWidth
  }
  
  onMounted(() => {
    window.addEventListener('resize', updateWidth)
  })
  
  onUnmounted(() => {
    window.removeEventListener('resize', updateWidth)
  })
  
  const isMobile = computed(() => width.value < breakpoints.sm)
  const isTablet = computed(() => 
    width.value >= breakpoints.sm && width.value < breakpoints.lg
  )
  const isDesktop = computed(() => width.value >= breakpoints.lg)
  
  const breakpoint = computed(() => {
    if (width.value < breakpoints.xs) return 'xs'
    if (width.value < breakpoints.sm) return 'sm'
    if (width.value < breakpoints.md) return 'md'
    if (width.value < breakpoints.lg) return 'lg'
    return 'xl'
  })
  
  return {
    width,
    isMobile,
    isTablet,
    isDesktop,
    breakpoint
  }
}
```

### ä¸»é¢˜ç³»ç»Ÿè®¾è®¡

```typescript
// src/composables/core/useTheme.ts
export const useTheme = () => {
  const themeStore = useThemeStore()
  
  // åº”ç”¨ä¸»é¢˜
  const applyTheme = (theme: ThemeConfig) => {
    const root = document.documentElement
    
    // è®¾ç½®CSSå˜é‡
    Object.entries(theme.colors).forEach(([key, value]) => {
      root.style.setProperty(`--color-${key}`, value)
    })
    
    // è®¾ç½®å­—ä½“
    root.style.setProperty('--font-family', theme.fonts.primary)
    
    // è®¾ç½®è¾¹è·
    Object.entries(theme.spacing).forEach(([key, value]) => {
      root.style.setProperty(`--spacing-${key}`, value)
    })
  }
  
  // åˆ‡æ¢ä¸»é¢˜
  const toggleTheme = () => {
    themeStore.toggleTheme()
    applyTheme(themeStore.currentTheme)
  }
  
  // åˆå§‹åŒ–ä¸»é¢˜
  const initTheme = () => {
    applyTheme(themeStore.currentTheme)
  }
  
  return {
    currentTheme: computed(() => themeStore.currentTheme),
    toggleTheme,
    initTheme
  }
}
```

---

## ğŸ“– ä¸‹ä¸€æ­¥é˜…è¯»

1. [æ ¸å¿ƒç»„ä»¶å®ç°](./04-å‰ç«¯æ ¸å¿ƒç»„ä»¶.md)
2. [é…ç½®æ–‡ä»¶è¯¦è§£](./05-å‰ç«¯é…ç½®æ–‡ä»¶.md)
3. [éƒ¨ç½²æ–¹æ¡ˆ](./06-å‰ç«¯éƒ¨ç½²æ–¹æ¡ˆ.md) 