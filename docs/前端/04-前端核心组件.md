# æ ¸å¿ƒç»„ä»¶å®ç°

## ğŸ“Š å›¾è¡¨ç»„ä»¶

### Kçº¿å›¾ç»„ä»¶

```vue
<!-- src/components/charts/KLineChart/index.vue -->
<template>
  <div class="kline-chart">
    <div class="chart-header">
      <div class="chart-title">
        <h3>{{ symbol }} - {{ symbolName }}</h3>
        <span class="chart-subtitle">{{ currentPeriodLabel }}</span>
      </div>
      
      <div class="chart-toolbar">
        <!-- æ—¶é—´å‘¨æœŸé€‰æ‹© -->
        <el-button-group class="period-selector">
          <el-button
            v-for="period in timePeriods"
            :key="period.value"
            :type="selectedPeriod === period.value ? 'primary' : 'default'"
            size="small"
            @click="changePeriod(period.value)"
          >
            {{ period.label }}
          </el-button>
        </el-button-group>
        
        <!-- æŒ‡æ ‡é€‰æ‹© -->
        <el-dropdown @command="addIndicator">
          <el-button size="small">
            æ·»åŠ æŒ‡æ ‡ <el-icon><ArrowDown /></el-icon>
          </el-button>
          <template #dropdown>
            <el-dropdown-menu>
              <el-dropdown-item 
                v-for="indicator in availableIndicators"
                :key="indicator.value"
                :command="indicator.value"
                :disabled="activeIndicators.includes(indicator.value)"
              >
                {{ indicator.label }}
              </el-dropdown-item>
            </el-dropdown-menu>
          </template>
        </el-dropdown>
        
        <!-- å…¨å±åˆ‡æ¢ -->
        <el-button 
          size="small" 
          :icon="fullscreen ? 'FullScreen' : 'FullScreen'" 
          @click="toggleFullscreen"
        />
      </div>
    </div>
    
    <div 
      ref="chartContainer" 
      class="chart-container"
      :class="{ 'fullscreen': fullscreen }"
    />
    
    <!-- æŒ‡æ ‡é…ç½®é¢æ¿ -->
    <div v-if="showIndicatorPanel" class="indicator-panel">
      <div class="panel-header">
        <span>æŒ‡æ ‡è®¾ç½®</span>
        <el-button text @click="showIndicatorPanel = false">
          <el-icon><Close /></el-icon>
        </el-button>
      </div>
      
      <div class="panel-content">
        <div 
          v-for="indicator in activeIndicators" 
          :key="indicator"
          class="indicator-item"
        >
          <div class="indicator-name">{{ getIndicatorLabel(indicator) }}</div>
          <div class="indicator-controls">
            <!-- åŠ¨æ€æŒ‡æ ‡å‚æ•°é…ç½® -->
            <component 
              :is="getIndicatorConfigComponent(indicator)"
              :config="indicatorConfigs[indicator]"
              @update="updateIndicatorConfig(indicator, $event)"
            />
            <el-button 
              size="small" 
              text 
              type="danger"
              @click="removeIndicator(indicator)"
            >
              åˆ é™¤
            </el-button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted, watch, nextTick } from 'vue'
import { ArrowDown, Close, FullScreen } from '@element-plus/icons-vue'
import { useChart } from '@/composables/chart/useChart'
import { useKLineData } from '@/composables/chart/useKLineData'
import { useIndicators } from '@/composables/chart/useIndicators'
import { useFullscreen } from '@/composables/core/useFullscreen'
import type { TimePeriod, KLineData, IndicatorType } from '@/types/chart'

interface Props {
  symbol: string
  symbolName?: string
  height?: string
  autoResize?: boolean
  showToolbar?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  symbolName: '',
  height: '400px',
  autoResize: true,
  showToolbar: true
})

const emit = defineEmits<{
  (e: 'period-change', period: TimePeriod): void
  (e: 'data-update', data: KLineData[]): void
  (e: 'indicator-add', indicator: IndicatorType): void
  (e: 'indicator-remove', indicator: IndicatorType): void
}>()

// å›¾è¡¨å®¹å™¨å¼•ç”¨
const chartContainer = ref<HTMLElement>()

// å›¾è¡¨ç›¸å…³
const { 
  chart, 
  loading, 
  initChart, 
  updateChart, 
  showLoading, 
  hideLoading 
} = useChart(chartContainer)

// Kçº¿æ•°æ®ç›¸å…³
const {
  klineData,
  selectedPeriod,
  timePeriods,
  currentPeriodLabel,
  fetchKLineData,
  subscribeRealtime,
  unsubscribeRealtime
} = useKLineData()

// æŠ€æœ¯æŒ‡æ ‡ç›¸å…³ - ä»åç«¯è·å–è®¡ç®—ç»“æœ
const {
  availableIndicators,
  activeIndicators,
  indicatorConfigs,
  calculatedIndicators,
  addIndicator,
  removeIndicator,
  updateIndicatorConfig,
  getIndicatorLabel,
  getIndicatorConfigComponent
} = useIndicators()

// å…¨å±ç›¸å…³
const { isFullscreen, toggle: toggleFullscreen } = useFullscreen(chartContainer)
const fullscreen = computed(() => isFullscreen.value)

// UIçŠ¶æ€
const showIndicatorPanel = ref(false)

// è®¡ç®—å±æ€§
const chartOption = computed(() => {
  if (!klineData.value.length) return null

  const baseOption = {
    animation: false,
    grid: [
      {
        left: '10%',
        right: '8%',
        height: activeIndicators.value.length > 0 ? '50%' : '70%'
      },
      // æˆäº¤é‡ç½‘æ ¼
      {
        left: '10%',
        right: '8%',
        top: activeIndicators.value.length > 0 ? '65%' : '75%',
        height: '16%'
      },
      // æŒ‡æ ‡ç½‘æ ¼
      ...activeIndicators.value.map((_, index) => ({
        left: '10%',
        right: '8%',
        top: `${85 + index * 15}%`,
        height: '12%'
      }))
    ],
    xAxis: [
      // ä¸»å›¾Xè½´
      {
        type: 'category',
        data: klineData.value.map(item => item.timestamp),
        scale: true,
        boundaryGap: false,
        axisLine: { onZero: false },
        splitLine: { show: false },
        min: 'dataMin',
        max: 'dataMax',
        axisPointer: {
          z: 100
        }
      },
      // æˆäº¤é‡Xè½´
      {
        type: 'category',
        gridIndex: 1,
        data: klineData.value.map(item => item.timestamp),
        scale: true,
        boundaryGap: false,
        axisLine: { onZero: false },
        axisTick: { show: false },
        splitLine: { show: false },
        axisLabel: { show: false },
        min: 'dataMin',
        max: 'dataMax'
      },
      // æŒ‡æ ‡Xè½´
      ...activeIndicators.value.map((_, index) => ({
        type: 'category',
        gridIndex: index + 2,
        data: klineData.value.map(item => item.timestamp),
        scale: true,
        boundaryGap: false,
        axisLine: { onZero: false },
        axisTick: { show: false },
        splitLine: { show: false },
        axisLabel: { show: false },
        min: 'dataMin',
        max: 'dataMax'
      }))
    ],
    yAxis: [
      // ä¸»å›¾Yè½´
      {
        scale: true,
        splitArea: { show: true }
      },
      // æˆäº¤é‡Yè½´
      {
        scale: true,
        gridIndex: 1,
        splitNumber: 2,
        axisLabel: { show: false },
        axisLine: { show: false },
        axisTick: { show: false },
        splitLine: { show: false }
      },
      // æŒ‡æ ‡Yè½´
      ...activeIndicators.value.map((_, index) => ({
        scale: true,
        gridIndex: index + 2,
        splitNumber: 2,
        axisLabel: { show: false },
        axisLine: { show: false },
        axisTick: { show: false },
        splitLine: { show: false }
      }))
    ],
    dataZoom: [
      {
        type: 'inside',
        xAxisIndex: Array.from({ length: activeIndicators.value.length + 2 }, (_, i) => i),
        start: 70,
        end: 100
      },
      {
        show: true,
        xAxisIndex: Array.from({ length: activeIndicators.value.length + 2 }, (_, i) => i),
        type: 'slider',
        top: '90%',
        start: 70,
        end: 100
      }
    ],
    series: [
      // Kçº¿å›¾
      {
        name: 'Kçº¿',
        type: 'candlestick',
        data: klineData.value.map(item => [item.open, item.close, item.low, item.high]),
        itemStyle: {
          color: '#ec0000',
          color0: '#00da3c',
          borderColor: '#8A0000',
          borderColor0: '#008F28'
        },
        markPoint: {
          label: {
            formatter: function (param: any) {
              return param != null ? Math.round(param.value) + '' : ''
            }
          },
          data: [
            {
              name: 'highest value',
              type: 'max',
              valueDim: 'highest'
            },
            {
              name: 'lowest value',
              type: 'min',
              valueDim: 'lowest'
            }
          ],
          tooltip: {
            formatter: function (param: any) {
              return param.name + '<br>' + (param.data.coord || '')
            }
          }
        }
      },
      // æˆäº¤é‡
      {
        name: 'æˆäº¤é‡',
        type: 'bar',
        xAxisIndex: 1,
        yAxisIndex: 1,
        data: klineData.value.map(item => item.volume),
        itemStyle: {
          color: function(params: any) {
            const dataIndex = params.dataIndex
            const klineItem = klineData.value[dataIndex]
            return klineItem.close > klineItem.open ? '#ec0000' : '#00da3c'
          }
        }
      },
      // æŠ€æœ¯æŒ‡æ ‡ç³»åˆ—
      ...generateIndicatorSeries()
    ],
    tooltip: {
      trigger: 'axis',
      axisPointer: {
        type: 'cross'
      },
      backgroundColor: 'rgba(245, 245, 245, 0.8)',
      borderWidth: 1,
      borderColor: '#ccc',
      padding: 10,
      textStyle: {
        color: '#000'
      },
      formatter: function (params: any) {
        let result = `æ—¶é—´ï¼š${params[0].axisValue}<br/>`
        
        params.forEach((param: any) => {
          if (param.seriesName === 'Kçº¿') {
            const data = param.data
            result += `å¼€ç›˜ï¼š${data[1]}<br/>`
            result += `æœ€é«˜ï¼š${data[4]}<br/>`
            result += `æœ€ä½ï¼š${data[3]}<br/>`
            result += `æ”¶ç›˜ï¼š${data[2]}<br/>`
          } else if (param.seriesName === 'æˆäº¤é‡') {
            result += `æˆäº¤é‡ï¼š${param.data}<br/>`
          } else {
            result += `${param.seriesName}ï¼š${param.data}<br/>`
          }
        })
        
        return result
      }
    }
  }

  return baseOption
})

// ç”ŸæˆæŒ‡æ ‡ç³»åˆ—
const generateIndicatorSeries = () => {
  const series: any[] = []
  
  activeIndicators.value.forEach((indicatorType, index) => {
    const indicatorData = calculatedIndicators.value[indicatorType]
    if (!indicatorData) return
    
    const gridIndex = index + 2
    const yAxisIndex = index + 2
    const xAxisIndex = index + 2
    
    // æ ¹æ®æŒ‡æ ‡ç±»å‹ç”Ÿæˆä¸åŒçš„ç³»åˆ—
    switch (indicatorType) {
      case 'MA':
        Object.entries(indicatorData).forEach(([period, data]) => {
          series.push({
            name: `MA${period}`,
            type: 'line',
            data,
            smooth: true,
            lineStyle: { width: 1 },
            showSymbol: false
          })
        })
        break
        
      case 'MACD':
        series.push(
          {
            name: 'DIF',
            type: 'line',
            xAxisIndex,
            yAxisIndex,
            data: indicatorData.dif,
            lineStyle: { color: '#2ec7c9', width: 1 },
            showSymbol: false
          },
          {
            name: 'DEA',
            type: 'line',
            xAxisIndex,
            yAxisIndex,
            data: indicatorData.dea,
            lineStyle: { color: '#b6a2de', width: 1 },
            showSymbol: false
          },
          {
            name: 'MACD',
            type: 'bar',
            xAxisIndex,
            yAxisIndex,
            data: indicatorData.macd,
            itemStyle: {
              color: function(params: any) {
                return params.data > 0 ? '#ec0000' : '#00da3c'
              }
            }
          }
        )
        break
        
      case 'RSI':
        series.push({
          name: 'RSI',
          type: 'line',
          xAxisIndex,
          yAxisIndex,
          data: indicatorData,
          lineStyle: { color: '#ffb980', width: 1 },
          showSymbol: false
        })
        break
    }
  })
  
  return series
}

// åˆ‡æ¢æ—¶é—´å‘¨æœŸ
const changePeriod = async (period: TimePeriod) => {
  if (period === selectedPeriod.value) return
  
  showLoading('åŠ è½½Kçº¿æ•°æ®...')
  
  try {
    await fetchKLineData(props.symbol, period)
    emit('period-change', period)
    emit('data-update', klineData.value)
  } catch (error) {
    console.error('åˆ‡æ¢å‘¨æœŸå¤±è´¥:', error)
  } finally {
    hideLoading()
  }
}

// æ·»åŠ æŒ‡æ ‡
const handleAddIndicator = (indicator: IndicatorType) => {
  addIndicator(indicator)
  emit('indicator-add', indicator)
  showIndicatorPanel.value = true
}

// ç§»é™¤æŒ‡æ ‡
const handleRemoveIndicator = (indicator: IndicatorType) => {
  removeIndicator(indicator)
  emit('indicator-remove', indicator)
  
  if (activeIndicators.value.length === 0) {
    showIndicatorPanel.value = false
  }
}

// åˆå§‹åŒ–
onMounted(async () => {
  await nextTick()
  await initChart()
  
  // åŠ è½½åˆå§‹æ•°æ®
  showLoading('åŠ è½½Kçº¿æ•°æ®...')
  
  try {
    await fetchKLineData(props.symbol, selectedPeriod.value)
    subscribeRealtime(props.symbol)
  } catch (error) {
    console.error('åˆå§‹åŒ–æ•°æ®åŠ è½½å¤±è´¥:', error)
  } finally {
    hideLoading()
  }
})

// æ¸…ç†
onUnmounted(() => {
  unsubscribeRealtime(props.symbol)
})

// ç›‘å¬æ•°æ®å˜åŒ–æ›´æ–°å›¾è¡¨
watch(
  chartOption,
  (newOption) => {
    if (newOption && chart.value) {
      updateChart(newOption)
    }
  },
  { deep: true }
)

// ç›‘å¬é€‰ä¸­è‚¡ç¥¨çš„è¡Œæƒ…æ›´æ–°
watch(selectedStock, (newStock, oldStock) => {
  if (oldStock) {
    unsubscribeQuote(oldStock.symbol)
  }
  
  if (newStock) {
    // ä½¿ç”¨åŸç”ŸWebSocketè®¢é˜…è¡Œæƒ…
    subscribeQuote(newStock.symbol)
  }
})
</script>

<style scoped>
.kline-chart {
  display: flex;
  flex-direction: column;
  height: 100%;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.chart-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  border-bottom: 1px solid #e8e8e8;
}

.chart-title h3 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
  color: #333;
}

.chart-subtitle {
  font-size: 14px;
  color: #666;
  margin-left: 8px;
}

.chart-toolbar {
  display: flex;
  align-items: center;
  gap: 12px;
}

.period-selector {
  display: flex;
}

.chart-container {
  flex: 1;
  min-height: 0;
  padding: 16px;
}

.chart-container.fullscreen {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 9999;
  background: white;
  padding: 20px;
}

.indicator-panel {
  position: absolute;
  top: 60px;
  right: 16px;
  width: 300px;
  background: white;
  border: 1px solid #e8e8e8;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  z-index: 1000;
}

.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  border-bottom: 1px solid #e8e8e8;
  font-weight: 600;
}

.panel-content {
  padding: 16px;
}

.indicator-item {
  margin-bottom: 16px;
}

.indicator-item:last-child {
  margin-bottom: 0;
}

.indicator-name {
  font-weight: 500;
  margin-bottom: 8px;
  color: #333;
}

.indicator-controls {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

@media (max-width: 768px) {
  .chart-header {
    flex-direction: column;
    gap: 12px;
    align-items: flex-start;
  }
  
  .chart-toolbar {
    width: 100%;
    justify-content: space-between;
  }
  
  .period-selector {
    flex-wrap: wrap;
  }
  
  .indicator-panel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    max-width: 400px;
  }
}
</style>
```

## ğŸ’° äº¤æ˜“ç»„ä»¶

### è®¢å•è¡¨å•ç»„ä»¶

```vue
<!-- src/components/trading/OrderForm/index.vue -->
<template>
  <div class="order-form">
    <div class="form-header">
      <h3>ä¸‹å•äº¤æ˜“</h3>
      <div class="account-info">
        <span>å¯ç”¨èµ„é‡‘: {{ formatCurrency(availableCash) }}</span>
      </div>
    </div>
    
    <el-form
      ref="formRef"
      :model="form"
      :rules="rules"
      label-width="80px"
      @submit.prevent="handleSubmit"
    >
      <!-- è‚¡ç¥¨é€‰æ‹© -->
      <el-form-item label="è‚¡ç¥¨ä»£ç " prop="symbol">
        <el-autocomplete
          v-model="form.symbol"
          :fetch-suggestions="searchStocks"
          placeholder="è¾“å…¥è‚¡ç¥¨ä»£ç æˆ–åç§°"
          style="width: 100%"
          :loading="searchLoading"
          @select="handleStockSelect"
          @blur="handleSymbolBlur"
        >
          <template #default="{ item }">
            <div class="stock-option">
              <div class="stock-info">
                <span class="stock-code">{{ item.symbol }}</span>
                <span class="stock-name">{{ item.name }}</span>
              </div>
              <div class="stock-price">
                <span 
                  class="price"
                  :class="getPriceClass(item.changePercent)"
                >
                  {{ formatPrice(item.currentPrice) }}
                </span>
                <span 
                  class="change"
                  :class="getPriceClass(item.changePercent)"
                >
                  {{ formatChange(item.change, item.changePercent) }}
                </span>
              </div>
            </div>
          </template>
        </el-autocomplete>
      </el-form-item>
      
      <!-- äº¤æ˜“æ–¹å‘ -->
      <el-form-item label="äº¤æ˜“æ–¹å‘">
        <el-radio-group v-model="form.side" @change="handleSideChange">
          <el-radio-button value="buy" class="buy-button">
            ä¹°å…¥
          </el-radio-button>
          <el-radio-button value="sell" class="sell-button">
            å–å‡º
          </el-radio-button>
        </el-radio-group>
      </el-form-item>
      
      <!-- è®¢å•ç±»å‹ -->
      <el-form-item label="è®¢å•ç±»å‹" prop="orderType">
        <el-select v-model="form.orderType" style="width: 100%" @change="handleOrderTypeChange">
          <el-option label="é™ä»·å•" value="limit" />
          <el-option label="å¸‚ä»·å•" value="market" />
          <el-option label="æ­¢æŸå•" value="stop" />
          <el-option label="æ­¢ç›ˆå•" value="stop-profit" />
        </el-select>
      </el-form-item>
      
      <!-- ä»·æ ¼è®¾ç½® -->
      <el-form-item 
        v-if="showPriceInput" 
        label="å§”æ‰˜ä»·æ ¼" 
        prop="price"
      >
        <div class="price-input-group">
          <el-input-number
            v-model="form.price"
            :precision="2"
            :step="0.01"
            :min="0"
            style="width: 100%"
            placeholder="è¾“å…¥å§”æ‰˜ä»·æ ¼"
            @change="calculateAmount"
          />
          <div class="price-buttons">
            <el-button 
              size="small" 
              @click="setPriceByMarket(-0.01)"
              :disabled="!selectedStock"
            >
              -1%
            </el-button>
            <el-button 
              size="small" 
              @click="setPriceByMarket(0)"
              :disabled="!selectedStock"
            >
              ç°ä»·
            </el-button>
            <el-button 
              size="small" 
              @click="setPriceByMarket(0.01)"
              :disabled="!selectedStock"
            >
              +1%
            </el-button>
          </div>
        </div>
      </el-form-item>
      
      <!-- æ•°é‡è®¾ç½® -->
      <el-form-item label="å§”æ‰˜æ•°é‡" prop="quantity">
        <div class="quantity-input-group">
          <el-input-number
            v-model="form.quantity"
            :precision="0"
            :step="100"
            :min="0"
            :max="maxQuantity"
            style="width: 100%"
            placeholder="è¾“å…¥å§”æ‰˜æ•°é‡"
            @change="calculateAmount"
          />
          <div class="quantity-buttons">
            <el-button 
              size="small" 
              @click="setQuantityByPercent(0.25)"
              :disabled="!canCalculateQuantity"
            >
              1/4
            </el-button>
            <el-button 
              size="small" 
              @click="setQuantityByPercent(0.5)"
              :disabled="!canCalculateQuantity"
            >
              1/2
            </el-button>
            <el-button 
              size="small" 
              @click="setQuantityByPercent(1)"
              :disabled="!canCalculateQuantity"
            >
              å…¨éƒ¨
            </el-button>
          </div>
        </div>
      </el-form-item>
      
      <!-- é‡‘é¢æ˜¾ç¤º -->
      <el-form-item label="å§”æ‰˜é‡‘é¢">
        <div class="amount-display">
          <span class="amount">{{ formatCurrency(estimatedAmount) }}</span>
          <span class="fee">æ‰‹ç»­è´¹: {{ formatCurrency(estimatedFee) }}</span>
        </div>
      </el-form-item>
      
      <!-- æŒä»“ä¿¡æ¯ (å–å‡ºæ—¶æ˜¾ç¤º) -->
      <el-form-item v-if="form.side === 'sell' && currentPosition" label="æŒä»“ä¿¡æ¯">
        <div class="position-info">
          <div class="position-row">
            <span>æŒä»“æ•°é‡:</span>
            <span>{{ currentPosition.totalQuantity }}</span>
          </div>
          <div class="position-row">
            <span>å¯å–æ•°é‡:</span>
            <span>{{ currentPosition.availableQuantity }}</span>
          </div>
          <div class="position-row">
            <span>æˆæœ¬ä»·:</span>
            <span>{{ formatPrice(currentPosition.avgPrice) }}</span>
          </div>
          <div class="position-row">
            <span>æµ®åŠ¨ç›ˆäº:</span>
            <span :class="getPriceClass(currentPosition.unrealizedPnlPercent)">
              {{ formatCurrency(currentPosition.unrealizedPnl) }}
              ({{ formatPercent(currentPosition.unrealizedPnlPercent) }})
            </span>
          </div>
        </div>
      </el-form-item>
      
      <!-- é£é™©æç¤º -->
      <div v-if="riskWarnings.length > 0" class="risk-warnings">
        <el-alert
          v-for="warning in riskWarnings"
          :key="warning.type"
          :title="warning.message"
          :type="warning.level"
          :closable="false"
          show-icon
        />
      </div>
      
      <!-- æäº¤æŒ‰é’® -->
      <el-form-item>
        <el-button
          type="primary"
          :loading="submitting"
          :disabled="!canSubmit"
          style="width: 100%"
          size="large"
          @click="handleSubmit"
        >
          {{ submitButtonText }}
        </el-button>
      </el-form-item>
    </el-form>
    
    <!-- å¿«é€Ÿä¸‹å• -->
    <div class="quick-trade">
      <div class="quick-trade-header">
        <span>å¿«é€Ÿä¸‹å•</span>
        <el-switch v-model="quickTradeEnabled" />
      </div>
      
      <div v-if="quickTradeEnabled" class="quick-trade-panel">
        <!-- é¢„è®¾é‡‘é¢æŒ‰é’® -->
        <div class="preset-amounts">
          <el-button
            v-for="amount in presetAmounts"
            :key="amount"
            size="small"
            @click="setAmountPreset(amount)"
          >
            {{ formatCurrency(amount) }}
          </el-button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, reactive, watch, onMounted } from 'vue'
import { ElMessage, ElMessageBox } from 'element-plus'
import { useOrderForm } from '@/composables/trading/useOrderForm'
import { useMarketData } from '@/composables/market/useMarketData'
import { useTradingStore } from '@/stores/modules/trading'
import { useUserStore } from '@/stores/modules/user'
import { formatCurrency, formatPrice, formatPercent, formatChange } from '@/utils/formatters'
import type { OrderFormData, StockInfo, Position, RiskWarning } from '@/types/trading'

interface Props {
  defaultSymbol?: string
  defaultSide?: 'buy' | 'sell'
  quickTradeMode?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  defaultSymbol: '',
  defaultSide: 'buy',
  quickTradeMode: false
})

const emit = defineEmits<{
  (e: 'submit', data: OrderFormData): void
  (e: 'stock-select', stock: StockInfo): void
  (e: 'side-change', side: 'buy' | 'sell'): void
}>()

// Stores
const tradingStore = useTradingStore()
const userStore = useUserStore()

// Formç›¸å…³
const formRef = ref()
const {
  form,
  rules,
  submitting,
  resetForm,
  validateForm,
  submitOrder
} = useOrderForm()

// å¸‚åœºæ•°æ®ç›¸å…³
const {
  searchStocks: searchStocksApi,
  getStockInfo,
  subscribeQuote,
  unsubscribeQuote
} = useMarketData()

// çŠ¶æ€
const searchLoading = ref(false)
const selectedStock = ref<StockInfo | null>(null)
const quickTradeEnabled = ref(false)

// é¢„è®¾é‡‘é¢
const presetAmounts = [1000, 5000, 10000, 20000, 50000]

// è®¡ç®—å±æ€§
const availableCash = computed(() => tradingStore.account.availableCash)

const currentPosition = computed(() => {
  if (!form.symbol) return null
  return tradingStore.getPositionBySymbol(form.symbol)
})

const showPriceInput = computed(() => {
  return ['limit', 'stop', 'stop-profit'].includes(form.orderType)
})

const maxQuantity = computed(() => {
  if (form.side === 'sell' && currentPosition.value) {
    return currentPosition.value.availableQuantity
  }
  
  if (form.side === 'buy' && form.price > 0) {
    return Math.floor(availableCash.value / form.price / 100) * 100
  }
  
  return 0
})

const canCalculateQuantity = computed(() => {
  return form.side === 'buy' && form.price > 0 && availableCash.value > 0
})

const estimatedAmount = computed(() => {
  if (form.orderType === 'market' && selectedStock.value) {
    return selectedStock.value.currentPrice * form.quantity
  }
  return form.price * form.quantity
})

const estimatedFee = computed(() => {
  // ç®€åŒ–çš„æ‰‹ç»­è´¹è®¡ç®—ï¼Œå®é™…åº”è¯¥æ ¹æ®åˆ¸å•†è§„åˆ™
  const feeRate = 0.0003 // ä¸‡åˆ†ä¹‹ä¸‰
  const minFee = 5 // æœ€ä½5å…ƒ
  const fee = Math.max(estimatedAmount.value * feeRate, minFee)
  return fee
})

const canSubmit = computed(() => {
  if (submitting.value) return false
  if (!form.symbol || !form.quantity) return false
  
  if (showPriceInput.value && !form.price) return false
  
  if (form.side === 'sell') {
    return currentPosition.value && form.quantity <= currentPosition.value.availableQuantity
  }
  
  if (form.side === 'buy') {
    const totalAmount = estimatedAmount.value + estimatedFee.value
    return totalAmount <= availableCash.value
  }
  
  return false
})

const submitButtonText = computed(() => {
  if (submitting.value) return 'æäº¤ä¸­...'
  
  const action = form.side === 'buy' ? 'ä¹°å…¥' : 'å–å‡º'
  const symbol = selectedStock.value?.name || form.symbol
  
  if (form.quantity && symbol) {
    return `${action} ${symbol} ${form.quantity}è‚¡`
  }
  
  return action
})

const riskWarnings = computed(() => {
  const warnings: RiskWarning[] = []
  
  // æ£€æŸ¥èµ„é‡‘é£é™©
  if (form.side === 'buy') {
    const totalAmount = estimatedAmount.value + estimatedFee.value
    const riskRatio = totalAmount / availableCash.value
    
    if (riskRatio > 0.9) {
      warnings.push({
        type: 'capital',
        level: 'warning',
        message: 'æ­¤ç¬”äº¤æ˜“å°†å ç”¨å¤§éƒ¨åˆ†å¯ç”¨èµ„é‡‘ï¼Œè¯·æ³¨æ„é£é™©æ§åˆ¶'
      })
    }
  }
  
  // æ£€æŸ¥é›†ä¸­åº¦é£é™©
  if (form.side === 'buy' && selectedStock.value) {
    const currentValue = currentPosition.value 
      ? currentPosition.value.marketValue 
      : 0
    const totalValue = currentValue + estimatedAmount.value
    const portfolioValue = tradingStore.totalPositionValue
    
    if (portfolioValue > 0 && totalValue / portfolioValue > 0.3) {
      warnings.push({
        type: 'concentration',
        level: 'warning',
        message: 'å•ä¸€è‚¡ç¥¨å æ¯”è¿‡é«˜ï¼Œå»ºè®®åˆ†æ•£æŠ•èµ„é™ä½é£é™©'
      })
    }
  }
  
  // æ£€æŸ¥ä»·æ ¼åç¦»
  if (showPriceInput.value && selectedStock.value && form.price > 0) {
    const deviation = Math.abs(form.price - selectedStock.value.currentPrice) / selectedStock.value.currentPrice
    
    if (deviation > 0.05) {
      warnings.push({
        type: 'price',
        level: 'warning',
        message: 'å§”æ‰˜ä»·æ ¼åç¦»å¸‚ä»·è¾ƒå¤§ï¼Œè¯·ç¡®è®¤ä»·æ ¼æ˜¯å¦æ­£ç¡®'
      })
    }
  }
  
  return warnings
})

// æ–¹æ³•
const searchStocks = async (queryString: string, cb: Function) => {
  if (!queryString) {
    cb([])
    return
  }
  
  searchLoading.value = true
  
  try {
    const results = await searchStocksApi(queryString)
    cb(results)
  } catch (error) {
    console.error('æœç´¢è‚¡ç¥¨å¤±è´¥:', error)
    cb([])
  } finally {
    searchLoading.value = false
  }
}

const handleStockSelect = async (item: StockInfo) => {
  selectedStock.value = item
  form.symbol = item.symbol
  
  // è®¾ç½®é»˜è®¤ä»·æ ¼ä¸ºå½“å‰ä»·
  if (showPriceInput.value) {
    form.price = item.currentPrice
  }
  
  // è®¢é˜…å®æ—¶è¡Œæƒ…
  subscribeQuote(item.symbol)
  
  emit('stock-select', item)
  
  // é‡æ–°è®¡ç®—é‡‘é¢
  calculateAmount()
}

const handleSymbolBlur = async () => {
  if (form.symbol && !selectedStock.value) {
    try {
      const stockInfo = await getStockInfo(form.symbol)
      if (stockInfo) {
        await handleStockSelect(stockInfo)
      }
    } catch (error) {
      console.error('è·å–è‚¡ç¥¨ä¿¡æ¯å¤±è´¥:', error)
    }
  }
}

const handleSideChange = (side: 'buy' | 'sell') => {
  emit('side-change', side)
  
  // å–å‡ºæ—¶æ£€æŸ¥æŒä»“
  if (side === 'sell' && !currentPosition.value) {
    ElMessage.warning('æ‚¨æ²¡æœ‰è¯¥è‚¡ç¥¨çš„æŒä»“')
  }
  
  // é‡æ–°è®¡ç®—æœ€å¤§æ•°é‡
  if (form.quantity > maxQuantity.value) {
    form.quantity = maxQuantity.value
  }
}

const handleOrderTypeChange = () => {
  // å¸‚ä»·å•æ—¶æ¸…ç©ºä»·æ ¼
  if (form.orderType === 'market') {
    form.price = 0
  } else if (selectedStock.value) {
    form.price = selectedStock.value.currentPrice
  }
  
  calculateAmount()
}

const setPriceByMarket = (offset: number) => {
  if (!selectedStock.value) return
  
  const basePrice = selectedStock.value.currentPrice
  form.price = Number((basePrice * (1 + offset)).toFixed(2))
  calculateAmount()
}

const setQuantityByPercent = (percent: number) => {
  if (form.side === 'sell' && currentPosition.value) {
    form.quantity = Math.floor(currentPosition.value.availableQuantity * percent / 100) * 100
  } else if (form.side === 'buy' && form.price > 0) {
    const maxAmount = availableCash.value * percent
    form.quantity = Math.floor(maxAmount / form.price / 100) * 100
  }
  
  calculateAmount()
}

const setAmountPreset = (amount: number) => {
  if (form.side === 'buy' && form.price > 0) {
    form.quantity = Math.floor(amount / form.price / 100) * 100
    calculateAmount()
  }
}

const calculateAmount = () => {
  // è§¦å‘å“åº”å¼æ›´æ–°
}

const getPriceClass = (changePercent: number) => {
  if (changePercent > 0) return 'price-up'
  if (changePercent < 0) return 'price-down'
  return 'price-neutral'
}

const handleSubmit = async () => {
  try {
    // è¡¨å•éªŒè¯
    await validateForm()
    
    // é£é™©ç¡®è®¤
    if (riskWarnings.value.some(w => w.level === 'error')) {
      ElMessage.error('å­˜åœ¨é£é™©é”™è¯¯ï¼Œæ— æ³•æäº¤è®¢å•')
      return
    }
    
    if (riskWarnings.value.some(w => w.level === 'warning')) {
      await ElMessageBox.confirm(
        'æ£€æµ‹åˆ°é£é™©è­¦å‘Šï¼Œæ˜¯å¦ç»§ç»­æäº¤è®¢å•ï¼Ÿ',
        'é£é™©æç¤º',
        {
          confirmButtonText: 'ç»§ç»­æäº¤',
          cancelButtonText: 'å–æ¶ˆ',
          type: 'warning'
        }
      )
    }
    
    // æäº¤è®¢å•
    await submitOrder()
    
    emit('submit', { ...form })
    
    ElMessage.success('è®¢å•æäº¤æˆåŠŸ')
    
    // é‡ç½®è¡¨å•
    resetForm()
    selectedStock.value = null
    
  } catch (error) {
    if (error !== 'cancel') {
      console.error('æäº¤è®¢å•å¤±è´¥:', error)
      ElMessage.error(error instanceof Error ? error.message : 'æäº¤è®¢å•å¤±è´¥')
    }
  }
}

// åˆå§‹åŒ–
onMounted(() => {
  if (props.defaultSymbol) {
    form.symbol = props.defaultSymbol
    handleSymbolBlur()
  }
  
  if (props.defaultSide) {
    form.side = props.defaultSide
  }
  
  if (props.quickTradeMode) {
    quickTradeEnabled.value = true
  }
})
</script>

<style scoped>
.order-form {
  background: white;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding-bottom: 12px;
  border-bottom: 1px solid #e8e8e8;
}

.form-header h3 {
  margin: 0;
  font-size: 18px;
  color: #333;
}

.account-info {
  font-size: 14px;
  color: #666;
}

.stock-option {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
}

.stock-info {
  display: flex;
  flex-direction: column;
}

.stock-code {
  font-weight: 600;
  color: #333;
}

.stock-name {
  font-size: 12px;
  color: #666;
}

.stock-price {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
}

.price, .change {
  font-size: 14px;
}

.price-up {
  color: #f56c6c;
}

.price-down {
  color: #67c23a;
}

.price-neutral {
  color: #909399;
}

.buy-button {
  color: #f56c6c;
}

.sell-button {
  color: #67c23a;
}

.price-input-group, .quantity-input-group {
  width: 100%;
}

.price-buttons, .quantity-buttons {
  display: flex;
  gap: 4px;
  margin-top: 8px;
}

.amount-display {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.amount {
  font-size: 16px;
  font-weight: 600;
  color: #333;
}

.fee {
  font-size: 12px;
  color: #666;
}

.position-info {
  background: #f5f7fa;
  padding: 12px;
  border-radius: 4px;
}

.position-row {
  display: flex;
  justify-content: space-between;
  margin-bottom: 4px;
}

.position-row:last-child {
  margin-bottom: 0;
}

.risk-warnings {
  margin: 16px 0;
}

.risk-warnings .el-alert {
  margin-bottom: 8px;
}

.risk-warnings .el-alert:last-child {
  margin-bottom: 0;
}

.quick-trade {
  margin-top: 20px;
  padding-top: 16px;
  border-top: 1px solid #e8e8e8;
}

.quick-trade-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.preset-amounts {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

@media (max-width: 768px) {
  .order-form {
    padding: 16px;
  }
  
  .form-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
  }
  
  .stock-option {
    flex-direction: column;
    align-items: flex-start;
    gap: 4px;
  }
  
  .price-buttons, .quantity-buttons {
    justify-content: space-between;
  }
  
  .preset-amounts {
    justify-content: space-between;
  }
}
</style>
```

---

## ğŸ“– ä¸‹ä¸€æ­¥é˜…è¯»

1. [é…ç½®æ–‡ä»¶è¯¦è§£](./05-å‰ç«¯é…ç½®æ–‡ä»¶.md)
2. [éƒ¨ç½²æ–¹æ¡ˆ](./06-å‰ç«¯éƒ¨ç½²æ–¹æ¡ˆ.md)
3. [å¼€å‘è§„èŒƒ](./08-å‰ç«¯å¼€å‘è§„èŒƒ.md) 